# backend/alembic/versions/06d47e30adc3_reinitialise_schema_and_add_budgeting.py

"""Reinitialise schema and add budgeting

Revision ID: 06d47e30adc3
Revises: 
Create Date: 2025-06-25 11:09:16.817888

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision: str = '06d47e30adc3' # Убедитесь, что это ID вашей текущей миграции
down_revision: Union[str, None] = None # Это первая миграция, поэтому None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###

    # Шаг 1: Удаляем ВСЕ существующие таблицы с CASCADE, если они существуют
    # Используем DROP TABLE IF EXISTS для идемпотентности и избежания UndefinedTable
    op.execute(sa.text("DROP TABLE IF EXISTS budget_items CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS budgets CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS transactions CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS mapping_rules CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS accounts CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS dds_articles CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS workspaces CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS users CASCADE;"))
    op.execute(sa.text("DROP TABLE IF EXISTS roles CASCADE;"))

    # Шаг 2.5: Сброс последовательности для таблицы roles перед ее созданием
    op.execute(sa.text("DROP SEQUENCE IF EXISTS roles_id_seq CASCADE;"))

    # Шаг 3: Создаем ВСЕ необходимые таблицы с обновленной схемой, используя RAW SQL
    # ПОРЯДОК СОЗДАНИЯ ТАБЛИЦ КРИТИЧЕН ИЗ-ЗА ВНЕШНИХ КЛЮЧЕЙ:
    # roles -> users (без active_workspace_id FK) -> workspaces -> users (добавляем FK active_workspace_id) -> accounts, dds_articles -> transactions, mapping_rules -> budgets -> budget_items

    # 3.1 Создаем таблицу roles
    op.execute(sa.text("""
        CREATE TABLE roles (
            id SERIAL PRIMARY KEY,
            name VARCHAR(50) NOT NULL UNIQUE,
            description TEXT
        );
    """))
    # Вставка начальных данных в таблицу roles с использованием op.bulk_insert
    op.bulk_insert(
        sa.Table(
            'roles',
            sa.MetaData(),
            sa.Column('id', sa.Integer, primary_key=True),
            sa.Column('name', sa.String(50)),
            sa.Column('description', sa.Text)
        ),
        [
            {'name': 'admin', 'description': 'Администратор. Полный доступ ко всем функциям, включая управление пользователями.'},
            {'name': 'employee', 'description': 'Сотрудник. Может создавать и редактировать операции, просматривать отчеты.'}
        ]
    )

    # 3.2 Создаем таблицу users (ВРЕМЕННО БЕЗ active_workspace_id FK)
    op.execute(sa.text("""
        CREATE TABLE users (
            id SERIAL PRIMARY KEY,
            role_id INTEGER REFERENCES roles(id), -- nullable=True as per models.py
            username VARCHAR(100) NOT NULL UNIQUE,
            email VARCHAR(255) NOT NULL UNIQUE,
            password_hash VARCHAR(255) NOT NULL, -- Используем password_hash
            full_name VARCHAR(255), -- nullable as per models.py
            is_active BOOLEAN NOT NULL DEFAULT TRUE,
            is_superuser BOOLEAN NOT NULL DEFAULT FALSE,
            active_workspace_id INTEGER, -- active_workspace_id создается, но БЕЗ REFERENCES workspaces(id) здесь
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_users_email ON users(email);"))
    op.execute(sa.text("CREATE INDEX idx_users_username ON users(username);"))

    # 3.3 Создаем таблицу workspaces (родитель для users.active_workspace_id и других)
    op.execute(sa.text("""
        CREATE TABLE workspaces (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            owner_id INTEGER NOT NULL REFERENCES users(id), -- FK к users
            currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_workspaces_name ON workspaces(name);"))

    # 3.4 ДОБАВЛЯЕМ ВНЕШНИЙ КЛЮЧ active_workspace_id К ТАБЛИЦЕ USERS, ТЕПЕРЬ, КОГДА WORKSPACES СУЩЕСТВУЕТ
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.create_foreign_key(
            "users_active_workspace_id_fkey", # Имя внешнего ключа
            "workspaces",                    # Таблица, на которую ссылается
            ["active_workspace_id"],         # Столбец в users
            ["id"]                           # Столбец в workspaces
        )

    # 3.5 Создаем таблицу accounts (ссылается на users и workspaces)
    op.execute(sa.text("""
        CREATE TABLE accounts (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            account_type VARCHAR(20) NOT NULL CHECK (account_type IN ('bank_account', 'cash_box')),
            currency VARCHAR(3) NOT NULL DEFAULT 'RUB',
            initial_balance NUMERIC(15, 2) NOT NULL DEFAULT 0.00,
            current_balance NUMERIC(15, 2) NOT NULL DEFAULT 0.00, 
            is_active BOOLEAN NOT NULL DEFAULT TRUE,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            workspace_id INTEGER NOT NULL REFERENCES workspaces(id),
            owner_id INTEGER NOT NULL REFERENCES users(id)
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_accounts_account_type ON accounts(account_type);"))
    op.execute(sa.text("CREATE INDEX idx_accounts_name ON accounts(name);"))

    # 3.6 Создаем таблицу dds_articles (ссылается на users и workspaces)
    op.execute(sa.text("""
        CREATE TABLE dds_articles (
            id SERIAL PRIMARY KEY,
            parent_id INTEGER REFERENCES dds_articles(id) ON DELETE SET NULL,
            name VARCHAR(255) NOT NULL,
            article_type VARCHAR(10) NOT NULL CHECK (article_type IN ('income', 'expense', 'group')), 
            is_archived BOOLEAN NOT NULL DEFAULT FALSE,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            workspace_id INTEGER NOT NULL REFERENCES workspaces(id),
            owner_id INTEGER NOT NULL REFERENCES users(id),
            code VARCHAR(255)
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_dds_articles_name ON dds_articles(name);"))
    op.execute(sa.text("CREATE INDEX idx_dds_articles_code ON dds_articles(code);"))


    # 3.7 Создаем таблицу mapping_rules (ссылается на dds_articles, users, workspaces)
    op.execute(sa.text("""
        CREATE TABLE mapping_rules (
            id SERIAL PRIMARY KEY,
            keyword VARCHAR(255) NOT NULL,
            dds_article_id INTEGER NOT NULL REFERENCES dds_articles(id),
            transaction_type VARCHAR(10),
            priority INTEGER NOT NULL DEFAULT 0,
            is_active BOOLEAN NOT NULL DEFAULT TRUE,
            owner_id INTEGER NOT NULL REFERENCES users(id),
            workspace_id INTEGER NOT NULL REFERENCES workspaces(id),
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            UNIQUE (keyword, workspace_id)
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_mapping_rules_keyword ON mapping_rules(keyword);"))


    # 3.8 Создаем таблицу transactions (ссылается на accounts, dds_articles, users)
    op.execute(sa.text("""
        CREATE TABLE transactions (
            id BIGSERIAL PRIMARY KEY,
            account_id INTEGER NOT NULL REFERENCES accounts(id),
            dds_article_id INTEGER REFERENCES dds_articles(id),
            transaction_date DATE NOT NULL,
            amount NUMERIC(15, 2) NOT NULL,
            description TEXT,
            contractor VARCHAR(255),
            employee VARCHAR(255),
            created_by_user_id INTEGER REFERENCES users(id),
            workspace_id INTEGER NOT NULL REFERENCES workspaces(id), 
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_transactions_account_id ON transactions(account_id);"))
    op.execute(sa.text("CREATE INDEX idx_transactions_dds_article_id ON transactions(dds_article_id);"))
    op.execute(sa.text("CREATE INDEX idx_transactions_transaction_date ON transactions(transaction_date);"))

    # 3.9 Создаем таблицу budgets (ссылается на users, workspaces)
    op.execute(sa.text("""
        CREATE TABLE budgets (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            start_date DATE NOT NULL,
            end_date DATE NOT NULL,
            owner_id INTEGER NOT NULL REFERENCES users(id),
            workspace_id INTEGER NOT NULL REFERENCES workspaces(id),
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            UNIQUE (name, workspace_id, start_date, end_date)
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_budgets_name ON budgets(name);"))

    # 3.10 Создаем таблицу budget_items (ссылается на budgets, dds_articles)
    op.execute(sa.text("""
        CREATE TABLE budget_items (
            id SERIAL PRIMARY KEY,
            budget_id INTEGER NOT NULL REFERENCES budgets(id),
            dds_article_id INTEGER NOT NULL REFERENCES dds_articles(id),
            budgeted_amount NUMERIC(15, 2) NOT NULL,
            type VARCHAR(10) NOT NULL,
            created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
            UNIQUE (budget_id, dds_article_id)
        );
    """))
    op.execute(sa.text("CREATE INDEX idx_budget_items_budget_id ON budget_items(budget_id);"))

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Удаляем внешний ключ active_workspace_id из users перед удалением workspaces
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_constraint("users_active_workspace_id_fkey", type_="foreignkey") # Имя FK из upgrade
    
    # Удаляем таблицы в ОБРАТНОМ ПОРЯДКЕ создания, чтобы не было проблем с FK
    op.drop_table('budget_items')
    op.drop_table('budgets')
    op.drop_table('transactions')
    op.drop_table('mapping_rules')
    op.drop_table('dds_articles')
    op.drop_table('accounts')
    op.drop_table('workspaces')
    op.drop_table('users')
    op.drop_table('roles')

    # ### end Alembic commands ###